<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiered GridMaster Randomizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(7, 60px);
            grid-template-rows: repeat(7, 60px);
            gap: 5px;
            padding: 10px;
            background-color: #333;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .grid-item {
            width: 60px;
            height: 60px;
            background-color: #555;
            border: 2px solid #777;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease, border-color 0.3s ease, transform 0.1s ease;
            position: relative;
            overflow: hidden;
        }
        .grid-item:hover:not(.finished):not(.current) {
            background-color: #777;
            transform: scale(1.05);
        }

        /* TIER COLORS FOR VISUAL AID */
        .grid-item.green-tier { background-color: #4CAF50; border-color: #388E3C; } /* Darker Green */
        .grid-item.yellow-tier { background-color: #FFC107; border-color: #FFA000; } /* Darker Yellow */
        .grid-item.red-tier { background-color: #F44336; border-color: #D32F2F; } /* Darker Red */


        .grid-item img {
            width: 90%;
            height: 90%;
            object-fit: contain;
            image-rendering: pixelated; 
            transition: opacity 0.3s ease;
        }
        .grid-item.finished {
            background-color: #28a745;
            border-color: #1e7e34;
        }
        .grid-item.finished img {
            opacity: 0.3;
        }
        .grid-item.finished::after {
            content: 'âœ”';
            position: absolute;
            font-size: 3em;
            color: white;
            opacity: 0.7;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .grid-item.current {
            background-color: #007bff;
            border-color: #0056b3;
            animation: pulse 1s infinite alternate;
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.7);
        }
        .grid-item.highlight-spin {
            animation: spinHighlight 0.5s ease-in-out forwards;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.08); }
        }
        @keyframes spinHighlight {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            50% { transform: scale(1.2) rotate(180deg); opacity: 0.8; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }

        .button-container {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        #randomizeButton {
            background-color: #ffc107;
        }
        #randomizeButton:hover:not(:disabled) {
            background-color: #e0a800;
        }
        
        #rerollButton {
            background-color: #fd7e14;
            color: white;
            display: none;
        }
        #rerollButton:hover:not(:disabled) {
            background-color: #e66a00;
        }
        
        #resetButton {
            background-color: #dc3545;
            color: white;
        }
        #resetButton:hover:not(:disabled) {
            background-color: #c82333;
        }

        #message {
            margin-top: 15px;
            font-size: 1.2em;
            color: #333;
            font-weight: bold;
            text-align: center;
        }

        #invalidRunMessage {
            margin-top: 10px;
            font-size: 1.1em;
            color: #dc3545;
            font-weight: bold;
            height: 1.2em;
        }
    </style>
</head>
<body>
    <h1>GridMaster Randomizer</h1>
    <div class="grid-container" id="challengeGrid">
        </div>
    
    <div class="button-container">
        <button id="randomizeButton">Find Next Challenge!</button>
        <button id="rerollButton">Reroll Challenge (Invalidates Run)</button>
        <button id="resetButton">Reset Grid</button>
    </div>

    <div id="message"></div>
    <div id="invalidRunMessage"></div>

    <script>
        const gridSize = 7;
        const totalTiles = gridSize * gridSize;
        const gridContainer = document.getElementById('challengeGrid');
        const randomizeButton = document.getElementById('randomizeButton');
        const messageDisplay = document.getElementById('message');

        const rerollButton = document.getElementById('rerollButton');
        const resetButton = document.getElementById('resetButton');
        const invalidRunMessage = document.getElementById('invalidRunMessage');

        // ==========================================================
        // TIER DEFINITIONS (Converted from 1-49 to 0-48 indices)
        // ==========================================================
        
        // Tiles 4,11,17,18,19,22,23,24,25,26,27,28,31,32,33,39,46
        const GREEN_TIER_INDICES = [
            3, 10, 16, 17, 18, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 38, 45
        ]; // 17 tiles

        // Tiles 3,5,9,10,12,13,15,16,20,21,29,30,34,35,37,38,40,41,45,47
        const YELLOW_TIER_INDICES = [
            2, 4, 8, 9, 11, 12, 14, 15, 19, 20, 28, 29, 33, 34, 36, 37, 39, 40, 44, 46
        ]; // 20 tiles

        // Tiles 1,2,6,7,8,14,36,42,43,44,48,49
        const RED_TIER_INDICES = [
            0, 1, 5, 6, 7, 13, 35, 41, 42, 43, 47, 48
        ]; // 12 tiles

        const TIER_ORDER = [
            { name: "Green Tier", indices: GREEN_TIER_INDICES, tilesRemaining: [] },
            { name: "Yellow Tier", indices: YELLOW_TIER_INDICES, tilesRemaining: [] },
            { name: "Red Tier", indices: RED_TIER_INDICES, tilesRemaining: [] }
        ];

        // ==========================================================
        // TILE DATA (YOUR FULL CHALLENGE LIST)
        // ==========================================================
        const tileData = [
            { name: "Defeat the Doom of Mokhaiotl at Depth 8", image: "icons/1.png" }, // 0
            { name: "Defeat Sol Heredith", image: "icons/2.png" }, // 1
            { name: "Fully decorate Magic Totem", image: "icons/3.png" }, // 2
            { name: "Kill an Ogress", image: "icons/4.png" }, // 3
            { name: "Defeat Jal-Zek", image: "icons/5.png" }, // 4
            { name: "Obtain a rare drop from Yama", image: "icons/6.png" }, // 5
            { name: "Obtain a rare drop from Xeric", image: "icons/7.png" }, // 6
            { name: "Reach 2000 total level", image: "icons/8.png" }, // 7
            { name: "Open the Lunar Chest", image: "icons/9.png" }, // 8
            { name: "Obtain a rare drop from the Hueycoatl", image: "icons/10.png" }, // 9
            { name: "Reach 500 total level", image: "icons/11.png" }, // 10
            { name: "Cook a shark while wearing a Cheft's hat", image: "icons/12.png" }, // 11
            { name: "Defeat Zulrah with a blowpipe", image: "icons/13.png" }, // 12
            { name: "Complete Inferno in 30 minutes or less", image: "icons/14.png" }, // 13
            { name: "Obtain some valuables from a house in Varlamore", image: "icons/15.png" }, // 14
            { name: "Obtain a rare drop from Barrows, while wearing rare Barrows equipment", image: "icons/16.png" }, // 15
            { name: "Drink a Steamforge brew at Stick Your Ore Inn", image: "icons/17.png" }, // 16
            { name: "Chop Maple Logs", image: "icons/18.png" }, // 17
            { name: "Defeat Scurrius", image: "icons/19.png" }, // 18
            { name: "Kill a Lizard Shaman", image: "icons/20.png" }, // 19
            { name: "Complete the Corruptet Gauntlet", image: "icons/21.png" }, // 20
            { name: "Gain over 30,000 coins from one Alchemy Spell", image: "icons/22.png" }, // 21
            { name: "Steal from a fruit stall", image: "icons/23.png" }, // 22
            { name: "Throw a gnomeball", image: "icons/24.png" }, // 23
            { name: "Complete the gridmaster tutorial", image: "icons/25.png" }, // 24 (CENTER TILE)
            { name: "Equip any boots from the Stronghold of Security", image: "icons/26.png" }, // 25
            { name: "Complete Vampyre Slayer", image: "icons/27.png" }, // 26
            { name: "Clean 3 grimy herbs", image: "icons/28.png" }, // 27
            { name: "Obtain a rare drop from Vorkath", image: "icons/29.png" }, // 28
            { name: "Catch a Moth barehanded", image: "icons/30.png" }, // 29
            { name: "Subdue Tempoross", image: "icons/31.png" }, // 30
            { name: "Mine Gold Ore", image: "icons/32.png" }, // 31
            { name: "Witness the Gemstone Crab burrow away", image: "icons/33.png" }, // 32
            { name: "Make a Zamorak brew while wearing Zamorak Monk Robe", image: "icons/34.png" }, // 33
            { name: "Defeat TzTok-Jad", image: "icons/35.png" }, // 34
            { name: "Defeat all 4 Awakened bosses", image: "icons/36.png" }, // 35
            { name: "Defeat Kalphite Queen", image: "icons/37.png" }, // 36
            { name: "Equip a unique item from the God Wars Dungeon", image: "icons/38.png" }, // 37
            { name: "Open Bryopytha's Chest", image: "icons/39.png" }, // 38
            { name: "Check a grown Fruit Tree", image: "icons/40.png" }, // 39
            { name: "Equip an Amulet of Fury", image: "icons/41.png" }, // 40
            { name: "Complete Floor 5 of The Hallowed Sephulchre", image: "icons/42.png" }, // 41
            { name: "Obtain a Rare drop from Tombs of Amascut", image: "icons/43.png" }, // 42
            { name: "Build a Demonic Throne in your POH", image: "icons/44.png" }, // 43
            { name: "Deposit a Skillcape to your POH", image: "icons/45.png" }, // 44
            { name: "Defeat a Lesser Demon in Wizard's Tower", image: "icons/46.png" }, // 45
            { name: "Reach 1500 total level", image: "icons/47.png" }, // 46
            { name: "Obtain a rare drop from Araxxor", image: "icons/48.png" }, // 47
            { name: "Obtain a rare drop from Theatre of Blood", image: "icons/49.png" }  // 48
        ];


        let finishedTiles = new Set();
        let currentTileIndex = -1;
        let isRandomizing = false;
        let runIsValid = true; 
        let activeTierIndex = 0; 

        // Helper function to get the current active tier's array
        function getCurrentTierTiles() {
            return TIER_ORDER[activeTierIndex].tilesRemaining;
        }

        // ==========================================================
        // LOCAL STORAGE FUNCTIONS
        // ==========================================================
        function saveGameState() {
            const gameState = {
                finishedTiles: Array.from(finishedTiles),
                currentTileIndex: currentTileIndex,
                runIsValid: runIsValid,
                activeTierIndex: activeTierIndex,
                tierStates: TIER_ORDER.map(tier => tier.tilesRemaining)
            };
            localStorage.setItem('gridChallengeState', JSON.stringify(gameState));
        }

        function loadGameState() {
            const savedState = localStorage.getItem('gridChallengeState');
            if (!savedState) return false;

            const gameState = JSON.parse(savedState);

            finishedTiles = new Set(gameState.finishedTiles);
            currentTileIndex = gameState.currentTileIndex;
            runIsValid = gameState.runIsValid;
            activeTierIndex = gameState.activeTierIndex;

            gameState.tierStates.forEach((remaining, index) => {
                TIER_ORDER[index].tilesRemaining = remaining;
            });

            return true;
        }

        // ==========================================================
        // initializeGrid (Handles Reset and Loading)
        // ==========================================================
        function initializeGrid(isReset = false) {
            
            // --- LOAD/RESET LOGIC ---
            if (isReset || !loadGameState()) {
                // If resetting or no save found, initialize to default state
                finishedTiles.clear();
                currentTileIndex = -1;
                runIsValid = true; 
                activeTierIndex = 0; 
                TIER_ORDER.forEach(tier => {
                    tier.tilesRemaining = [...tier.indices]; 
                });
                localStorage.removeItem('gridChallengeState'); // Clear local storage on hard reset
                saveGameState(); // Save the fresh starting state
            }
            
            // --- UI Setup (Runs every time, whether loading or fresh) ---
            gridContainer.innerHTML = ''; 
            isRandomizing = false;
            
            const currentPool = getCurrentTierTiles();

            // Set messages/buttons based on the current state
            if (runIsValid === false) {
                invalidRunMessage.textContent = 'This run is now invalid!';
            } else {
                invalidRunMessage.textContent = '';
            }
            
            if (finishedTiles.size === totalTiles) {
                messageDisplay.textContent = 'Congratulations! All challenges completed!';
                randomizeButton.disabled = true;
                rerollButton.style.display = 'none';
            } else if (currentTileIndex !== -1) {
                 const chosenTileData = tileData[currentTileIndex];
                 messageDisplay.textContent = `(${TIER_ORDER[activeTierIndex].name}) Your current challenge is: ${chosenTileData.name}! Click it when finished.`;
                 randomizeButton.disabled = true;
                 rerollButton.style.display = 'inline-block';
                 rerollButton.disabled = false;
            } else if (currentPool.length === 0 && (activeTierIndex + 1) < TIER_ORDER.length) {
                 messageDisplay.textContent = `Completed all challenges in the ${TIER_ORDER[activeTierIndex].name}! Click "Find Next Challenge!" to begin the ${TIER_ORDER[activeTierIndex + 1].name}.`;
                 randomizeButton.disabled = false;
                 rerollButton.style.display = 'none';
            } else {
                messageDisplay.textContent = 'Click the button to start your first challenge!';
                randomizeButton.disabled = false;
                rerollButton.style.display = 'none';
            }

            // Build the grid
            tileData.forEach((data, index) => {
                const gridItem = document.createElement('div');
                gridItem.classList.add('grid-item');
                gridItem.dataset.index = index; 

                // Add tier color classes
                if (GREEN_TIER_INDICES.includes(index)) {
                    gridItem.classList.add('green-tier');
                } else if (YELLOW_TIER_INDICES.includes(index)) {
                    gridItem.classList.add('yellow-tier');
                } else if (RED_TIER_INDICES.includes(index)) {
                    gridItem.classList.add('red-tier');
                }

                // Apply finished state from loaded data
                if (finishedTiles.has(index)) {
                    gridItem.classList.add('finished');
                }
                // Apply current state from loaded data
                if (index === currentTileIndex) {
                     gridItem.classList.add('current');
                }

                const icon = document.createElement('img');
                icon.src = data.image; 
                icon.alt = data.name;  
                
                gridItem.appendChild(icon); 
                gridContainer.appendChild(gridItem);
            });
        }

        // ==========================================================
        // performSpinAnimation
        // ==========================================================
        async function performSpinAnimation() {
            const animationDuration = 3000;
            const rollCount = 20;
            const delayBetweenSpins = animationDuration / rollCount;
            let lastHighlightedTile = null;
            const currentPool = getCurrentTierTiles();

            for (let i = 0; i < rollCount; i++) {
                const tempRandomIndex = currentPool[Math.floor(Math.random() * currentPool.length)];
                const tempTileElement = gridContainer.children[tempRandomIndex];

                if (lastHighlightedTile && lastHighlightedTile !== tempTileElement) {
                    lastHighlightedTile.classList.remove('highlight-spin');
                }
                tempTileElement.classList.add('highlight-spin');
                lastHighlightedTile = tempTileElement;

                await new Promise(resolve => setTimeout(resolve, delayBetweenSpins));
            }
            return lastHighlightedTile;
        }

        // ==========================================================
        // randomizeTile
        // ==========================================================
        async function randomizeTile() {
            if (isRandomizing) return;

            // Tier progression check
            if (getCurrentTierTiles().length === 0) {
                activeTierIndex++;
                if (activeTierIndex >= TIER_ORDER.length) {
                    messageDisplay.textContent = 'All challenges completed in all tiers!';
                    randomizeButton.disabled = true;
                    return;
                }
                messageDisplay.textContent = `Starting ${TIER_ORDER[activeTierIndex].name}! Finding first challenge...`;
            }
            
            isRandomizing = true;
            randomizeButton.disabled = true;
            rerollButton.disabled = true;
            messageDisplay.textContent = 'Choosing your next challenge...';

            if (currentTileIndex !== -1) {
                gridContainer.children[currentTileIndex].classList.remove('current');
            }
            
            const lastAnimatedTile = await performSpinAnimation();
            
            let chosenTileGridIndex;
            const currentPool = getCurrentTierTiles();

            // Forced Center Tile (Tile 24) logic
            if (activeTierIndex === 0 && currentPool.length === GREEN_TIER_INDICES.length) {
                chosenTileGridIndex = 24; 
            } else {
                const randomIndexInAvailable = Math.floor(Math.random() * currentPool.length);
                chosenTileGridIndex = currentPool[randomIndexInAvailable];
            }

            const indexInCurrentPool = currentPool.indexOf(chosenTileGridIndex);
            currentTileIndex = currentPool.splice(indexInCurrentPool, 1)[0]; 

            const finalChosenElement = gridContainer.children[currentTileIndex];
            if (lastAnimatedTile) {
                 lastAnimatedTile.classList.remove('highlight-spin');
            }
            finalChosenElement.classList.add('current');

            const chosenTileData = tileData[currentTileIndex];
            messageDisplay.textContent = `(${TIER_ORDER[activeTierIndex].name}) Your current challenge is: ${chosenTileData.name}! Click it when finished.`;

            isRandomizing = false;
            rerollButton.style.display = 'inline-block';
            rerollButton.disabled = false;
            
            // SAVE STATE AFTER SELECTION
            saveGameState(); 
        }

        // ==========================================================
        // rerollTile
        // ==========================================================
        async function rerollTile() {
            const currentPool = getCurrentTierTiles();
            if (isRandomizing || currentTileIndex === -1 || currentPool.length === 0) return;

            if (runIsValid) {
                runIsValid = false;
                invalidRunMessage.textContent = 'This run is now invalid!';
            }
            
            isRandomizing = true;
            rerollButton.disabled = true;
            messageDisplay.textContent = 'Rerolling challenge...';

            gridContainer.children[currentTileIndex].classList.remove('current');
            currentPool.push(currentTileIndex);

            const lastAnimatedTile = await performSpinAnimation();

            const randomIndexInAvailable = Math.floor(Math.random() * currentPool.length);
            currentTileIndex = currentPool.splice(randomIndexInAvailable, 1)[0]; 

            const finalChosenElement = gridContainer.children[currentTileIndex];
            if (lastAnimatedTile) {
                 lastAnimatedTile.classList.remove('highlight-spin');
            }
            finalChosenElement.classList.add('current');

            const chosenTileData = tileData[currentTileIndex];
            messageDisplay.textContent = `(${TIER_ORDER[activeTierIndex].name}) Your new challenge is: ${chosenTileData.name}! Click it when finished.`;

            isRandomizing = false;
            rerollButton.disabled = false;
            
            // SAVE STATE AFTER REROLL
            saveGameState();
        }


        // ==========================================================
        // Click listener
        // ==========================================================
        gridContainer.addEventListener('click', (event) => {
            const clickedItem = event.target.closest('.grid-item');
            if (!clickedItem || isRandomizing) return;

            const clickedIndex = parseInt(clickedItem.dataset.index);
            const clickedTileData = tileData[clickedIndex];

            if (clickedIndex === currentTileIndex && currentTileIndex !== -1) {
                clickedItem.classList.remove('current');
                clickedItem.classList.add('finished');
                finishedTiles.add(clickedIndex);
                currentTileIndex = -1;

                rerollButton.style.display = 'none';

                if (finishedTiles.size === totalTiles) {
                    messageDisplay.textContent = 'Congratulations! All challenges completed!';
                    randomizeButton.disabled = true;
                } else {
                    const currentPool = getCurrentTierTiles();
                    if (currentPool.length === 0 && (activeTierIndex + 1) < TIER_ORDER.length) {
                        messageDisplay.textContent = `Completed all challenges in the ${TIER_ORDER[activeTierIndex].name}! Click "Find Next Challenge!" to begin the ${TIER_ORDER[activeTierIndex + 1].name}.`;
                    } else {
                        messageDisplay.textContent = `Challenge "${clickedTileData.name}" completed! Find your next one.`;
                    }
                    randomizeButton.disabled = false;
                }
                // SAVE STATE AFTER COMPLETING TILE
                saveGameState(); 

            } else if (finishedTiles.has(clickedIndex)) {
                messageDisplay.textContent = `"${clickedTileData.name}" is already finished!`;
            } else if (currentTileIndex !== -1) {
                const currentTileData = tileData[currentTileIndex];
                messageDisplay.textContent = `You are currently on "${currentTileData.name}". Finish that one first!`;
            } else {
                 messageDisplay.textContent = `Click "Find Next Challenge!" to choose your first tile.`;
            }
        });

        randomizeButton.addEventListener('click', randomizeTile);
        rerollButton.addEventListener('click', rerollTile);
        // Reset button now calls initializeGrid(true) to force a hard reset
        resetButton.addEventListener('click', () => initializeGrid(true)); 

        // Initial setup: Loads state if available
        initializeGrid();
    </script>
</body>
</html>
